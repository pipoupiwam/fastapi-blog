import pytest_asyncio
from httpx import AsyncClient
from sqlalchemy import StaticPool
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine

from sqlalchemy.orm import sessionmaker
from app.database.models import Base
from freezegun import freeze_time
from app.main import app, get_db

# in memory async sqlite
DATABASE_URL = "sqlite+aiosqlite:///:memory:"




@pytest_asyncio.fixture
async def async_db_engine():
    """
    Generate an async database engine
    """
    async_engine = create_async_engine(
        DATABASE_URL, connect_args={"check_same_thread": False}, poolclass=StaticPool
    )
    async with async_engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    yield async_engine
    async with async_engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)

@pytest_asyncio.fixture
async def async_db(async_db_engine):
    # freeze database time to solve issues related to autogenerated datetime fields.
    with freeze_time("2046-01-01 12:00:00", real_asyncio=True):
        async_session = sessionmaker(
            expire_on_commit=False,
            autocommit=False,
            autoflush=False,
            bind=async_db_engine,
            class_=AsyncSession,
        )

        async with async_session() as session:
            await session.begin()
            yield session
            await session.rollback()

@pytest_asyncio.fixture
async def async_client(async_db):
    """
    Note : Fixtures are executed only once per test, async_db won't yield two different databases if used two times.
    """
    app.dependency_overrides[get_db] = lambda: async_db
    async with AsyncClient(app=app, base_url="http://testserver") as client:
        yield client
